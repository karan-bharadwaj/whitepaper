#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing onehalf
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Blockchain 2.0: Smart Contracts
\end_layout

\begin_layout Author
Karan Bharadwaj
\end_layout

\begin_layout Standard
The relevance of blockchain technology to the financial world has grown
 substantially over the last few years.
 An important aspect of the evaluation of blockchain tech is understanding
 its technical underpinnings to properly design for individual industries.
 The very first and wildly successful blockchain was the bitcoin cryptocurreny.
 While cryptocurrency based blockchains are largely incompatible with regulated
 financial industries, it is useful to look at, in some detail, the origins
 of the powerful paradigms that are being repurposed to service a myriad
 use cases.
 The most fundamental of these are 
\series bold
smart contracts
\series default
.
 In this paper we'll take a look at the earliest and most basic smart contracts
 as they were designed to serve the bitcoin blockchain and then move onto
 a much more sophisticated implementation via Ethereum.
 We'll also take a look at existing security loopholes and offer preliminary
 solutions in the context of enterprise private blockchain implementations.
\end_layout

\begin_layout Section*
The Origins of Smart Contracts
\end_layout

\begin_layout Standard
The bitcoin blockchain is a database of transactions.
 The transaction structure is comprised of 'inputs' and 'outputs'.
 These outputs are called unspent transaction outputs or 
\series bold
UTXO
\series default
s.
 UTXOs are the fundamental building blocks of the bitcoin blockchain.
 The bitcoin client keeps track of all UTXOs and the bitcoin balance in
 a particular wallet is constructed from these UTXOs registered to the correspon
ding wallet address(or public key).
 Each transaction generates outputs which are registered to the recipient.
 These UTXOs are locked with a script called the locking script that specifies
 the conditions necessary to spend that output.
 Most commonly the locking script locks the output to a specific bitcoin
 address(or public key).
 The inputs of a transaction are pointers to these scattered UTXOs in the
 blockchain.
 An unlocking script that allows for their ownership to be transferred is
 generated by the wallet once the appropriate UTXOs are selected .
 
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The Structure of a transaction.
\end_layout

\end_inset


\series bold
 
\series default

\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Size
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Field
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Version
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kind of transaction
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1-9 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Input Counter
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
How many inputs are included
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Variable
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Inputs
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
One or more inputs
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1-9 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Output Counter
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
How many outputs are included
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Variable
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Outputs
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
One or more outputs
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Locktime
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A timestamp or blocknumber
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/karn/Pictures/en-transaction-propagation.svg
	scale 50
	rotateOrigin leftTop

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The bitcoin client executes the locking and unlocking scripts to validate
 transactions and populate the blockchain.
 These scripts are written in a primitive language called 
\series bold
Script
\series default
.
 This simple language is intentionally 
\series bold
Turing-incomplete
\series default
, which means that no script can be looped, to prevent malicious attacks
 on the bitcoin network.
 While Script's simplicity is deliberate for security and computational
 reasons, the possibilities for creating more complex conditions for spending
 are tantalizing.
 These advanced scripted transactional rules are called Smart Contracts.
 Within the bitcoin ecosystem, simple smart contracts are implemented through
 the pay-to-script-hash(P2SH) transaction.
 In this kind of transaction, the locking script includes a hash of the
 encoded smart contract(called the redeem script), which is unlocked by
 the recipient who possesses the redeem script.
 
\end_layout

\begin_layout Standard
The implications smart contracts hold for the financial world are substantial.
 The technical underpinnings of transactions on the blockchain can provide
 a potent mechanism for transfers beyond those involving currencies.
 Sophisticated embedded code in the transactional scripts can give rise
 to 
\series bold
autonomous
\series default
 and 
\series bold
self-sufficient
\series default
 execution of transfers of value.
 Once two parties sign a smart contract, depending on the conditions encoded
 in the locking script, the contract executes autonomously.
 Neither party has the ability to change the terms of the contract once
 it has been executed.
 This autonomy coupled with the immutability of the blockchain, can result
 in a very secure digital trust mechanism.
 Self-sufficiency in the context of smart contract is the ability for the
 contract to access or dispense additional resources like obtaining processing
 power; as in the case of Ethereum.
 The ability of smart contracts to interact with other contracts and accounts
\end_layout

\begin_layout Section*
Smart Contracts Evolved: Ethereum
\end_layout

\begin_layout Standard
Ethereum is the most successful application of a smart contracts platform
 today.
 It was designed to be a more generalized blockchain where complex smart
 contracts can be created and executed.
 The Ethereum blockchain shares significant similarities with the Bitcoin
 blockchain.
 Transactions are appended in both networks via a proof-of-work consensus
 mechanism.
 The proof-of-work consensus is a computational exercise undertaken by the
 participants of the Ethereum network to create new blocks of transactions
 via a process called mining.
 In Ethereum two kinds of accounts can be created.
 The first is called an externally owned account(EOA), which is similar
 to a bitcoin account that stores an amount of currency.
 Transactions between two EOAs is the same as a bitcoin transaction between
 two wallets.
 Ethereum has a second kind of account called a contract.
 A contract account stores the contracts code and has it's own data storage.
 A transaction from an EOA to another EOA simply transfers a quantity of
 ether.
 A transaction to a contract account runs the contract code.
 The contract code has the ability to read the code, quantity of ether,
 and write to it's own storage.
 More importantly the contract can send a transaction to another contract
 account.
 When a contract executes it's code, it has the ability to create another
 contract as well.
 These last two properties of contract accounts give rise to powerful tools
 that can be used to create complicated smart contracts that satisfy a number
 of use cases 
\end_layout

\begin_layout Standard
Ethereum deviates significantly from the Bitcoin blockchain in the sophisticatio
n of it's scripting language.
 As stated above, the bitcoin scripting language was left intentionally
 primitive for security and scalability reasons.
 Ethereum's scripting language, called Solidity, is designed to create complex
 smart contracts.
 This added complexity comes at a cost though.
 The structure of the Etheruem network necessitates the running of all smart
 contracts on all of it's nodes(similar to the Bitcoin network).
 A malicious smart contract would be devastating to the entire network.
 The paradigm of the digital currency is reworked for the Ethereum case.
 The concept of gas, procured with ether, defines the number of computational
 steps an account can carry out.
 So a malicious attack which relied on abusing the halting problem scenario(expl
ained below) will need a continuous supply of gas to run it's computational
 steps.
 An elegant solution that removes security vulnerabilities at the most basic
 level.
 Unfortunately even though the Ethereum network is responsibly audited for
 security, applications built upon it may not have been subjected to a similar
 level of scrutiny.
 Let's assume a smart contract is created by A to pay out 20$ to B if the
 temperature on some day x is above 30 degrees c for the price of 10$.
 Such a contract can run a marketplace of such bets and lets people find,
 bid, and settle them.
 Two security problems arise from this arrangement.
 Our contract developer A can be a malicious individual and steal the money
 instead of settling or he could be an incompetent programmer whose poorly
 written code fails at some point of the execution.
 While both these situations are different, there are significant similarities
 in the possible solutions for these security loopholes.
 
\end_layout

\begin_layout Standard
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Subsubsection*
The Halting Problem
\end_layout

\begin_layout Plain Layout
The Goldbach conjecture states that every even integer greater than 2 can
 be expressed as the sum of two primes.
 What if we wrote a program that only halts if the Goldbach conjecture fails?
 
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def goldbach():
\end_layout

\begin_layout Plain Layout

  r=4
\end_layout

\begin_layout Plain Layout

  while True:
\end_layout

\begin_layout Plain Layout

    for p1 in range(r)
\end_layout

\begin_layout Plain Layout

      for p2 in range(r)
\end_layout

\begin_layout Plain Layout

	    if (prime(p1) && prime (p2)) && (p1+p2 == k)
\end_layout

\begin_layout Plain Layout

		  ok= True
\end_layout

\begin_layout Plain Layout

    if not ok:
\end_layout

\begin_layout Plain Layout

	  halt()
\end_layout

\begin_layout Plain Layout

    r+=2
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The above program only halts if the Goldbach conjecture is false.
 So far mathematicians have verified the Goldbach conjecture for r â‰¤ 10
\begin_inset script superscript

\begin_layout Plain Layout
18
\end_layout

\end_inset

.
 The pertinent question is whether we can create a program that if fed the
 above code can tell us if it halts or goes on forever.
 Intuitively one can see that such a program cannot exist and it's straightforwa
rd to prove as such .
 
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Security Concerns and Smart Contracts
\end_layout

\begin_layout Standard
The proposed security paradigm is divided into low level solutions and high
 level solutions.
 The low level security solutions necessitate the division of programs into
 two parts: core and interface.
 The core of the application is the smart contract itself which is stipulated
 to be small and extensively audited for security.
 The interface is the HTML and Javascript code that communicates with the
 core.
 At the higher level security solutions are harder to implement.
 The Ethereum programming language Solidity is currently being integrated
 with formal verification tools.
 Formal verification is the application of mathematical analysis by computer
 programs on other computer programs.
 In Ethereum, the currently experimental why3, a formal verification engine
 is being integrated into Solidity.
 However, there are complications in the application of this technology
 to smart contracts.
 The act of defining what is to be proved is extremely hard which makes
 the higher level implementation difficult and complex.
 
\end_layout

\begin_layout Standard
The Decentralized Autonomous Organization(DAO) built by the Slock.it for
 the Ethereum network was launched earlier this year.
 Technically speaking a DAO can be anything that is not owned by a central
 authority.
 Therefore the bitcoin network would be a DAO as well.
 The DAO being discussed here is a particular company that launched their
 program on the Ethereum network in April 2016.
 Generally a DAO is created when a group of developers write code(smart
 contracts) that defines the organization rules.
 As with the DAO created by Slock.it, there is a period of funding where
 a restricted ownership(limited to voting rights) is procured by users by
 buying coins(ether in this case).
 Once the funding period is over, the DAO can begin operation and it's members
 can decide on how the funds can be used by voting on proposals.
 The DAO launched on Ethereum was wildly successful and raised over $150m
 through 11,000 members over the period of a month.
 The DAO was unfortunately the victim of a hack through a known recursive
 calling vulnerability by calling the split function recursively.
 The result was that 3.6m ether($72 m) was drained into a child DAO with
 the same structure.
 The Ethereum developers responded with a temporary soft fork which froze
 the ability for accounts on the DAO from spending ether and subsequently
 a hard fork which recovered the stolen ether.
 
\end_layout

\begin_layout Standard
The promise of smart contracts is not without significant security concerns.
 While Ethereum brings sophisticated smart contracts functionality, it raises
 significant concerns in an industry where data security is paramount.
 While a private or permissioned network can exist within the Ethereum ecosystem
, the mechanisms to ensure a well developed framework for permissioned networks
 are in their infancy.
 
\end_layout

\begin_layout Section*
The Problem with 'Oracles'
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section*
Proposed Paradigm of Smart Contracts
\end_layout

\begin_layout Standard
The proposed solution is a permissioned blockchain with three defined layer
 to the protocol.
 At the lowest layer is the blockchain implementation where the ledger and
 various kinds of account structures exist.
 By design the lowest layer is use-case agnostic and can be comprehensively
 customized for a large variety of applications.
 In contrast to the Nakamoto lottery(proof of work) for the bitcoin and
 Ethereum blockchains, the choice of consensus is based on the Ripple Labs
 network consensus mechanism.
 In a public blockchain like Ethereum or bitcoin, a computaionally expensive
 proof of work mechanism is a necessity to prevent double spending.
 In a permissioned blockchain, consensus mechanisms are much lighter computation
ally and with very low settlement times(at the scale of seconds).
 Furthermore, permissioned blockchains run on trusted nodes which are inaccessib
le to the outside world which improves the security outlook of the application
 when compared to one on a public blockchain.
 
\end_layout

\begin_layout Standard
The middle layer is the core layer of the smart contract implementation.
 Individual smart contracts will be defined in a heavily audited system
 to ensure no lower level vulnerabilities exist in the code.
 The middle layer communicates with the blockchain layer directly.
 One manner in which smart contract robustness will be achieved is through
 completely private and highly customized development of the smart contract
 for the particular use case.
 In the banking use case, this core layer will perform the necessary identificat
ion, authentication, and communication without allowing for direct access
 to the lowest level which is the implementation of the blockchain.
 The top layer is the interface layer through with end customers will avail
 the service in question.
 This layer is similar to the web front end and will be written in similar
 ways.
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

Antonopoulos, Andreas.
 
\shape italic
Mastering Bitcoin
\shape default
.
 O'Reilly, 2014.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-2"

\end_inset

Swan, Melanie.
 
\shape italic
Blockchain: Blueprint For A New Economy
\shape default
.
 O'Reilly, 2015.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-3"

\end_inset

Buterin, Vitalik.
 
\shape italic
Ethereum: Platform Review
\shape default
.
 2016.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-4"

\end_inset

Buterin, Vitalik.
 
\shape italic
Hard Fork Completed
\shape default
 .
 www.blog.ethereum.org/2016/07/20/hard-fork-completed/, July, 2016.
\end_layout

\end_body
\end_document
